\chapter{Názov kapitoly 1}
\label{chap:kapitola1}

V tejto kapitole formálne definujem operácie z uvedenej dokumentácie jazyka Python \cite{Python3Documentation} a ukážem ich silu. Budem používať nasledovné zápisy:
\begin{list}{}{}
\item $ L_{1}L_{2} $ -- zreťazenie jazykov $ L_{1} $ a $ L_{2} $
\item $ L^* $ -- iterácia ($L^*=\cup^{\infty}_{i=0}L^i$, kde $L^0=\lbrace \varepsilon \rbrace$, $L^1=L$ a $L^{i+1}=L^iL$)
\item $ \R $ -- trieda regulárnych jazykov
\item $ \L_{CF}$ -- trieda bezkontextových jazykov
\item $ \L_{CS}$ -- trieda bezkontextových jazykov
\item DKA/NKA -- deterministický/nedeterministický konečný automat
\item LBA -- lineárne ohraničený Turingov stroj
\item regex -- regulárny výraz, ktorý môže vytvoriť najviac regulárny jazyk (základná definícia)
\item e-regex -- regex so spätnými referenciami
\item le-regex -- e-regex s operáciami lookahead a lookbehind
\item Eregex -- trieda jazykov tvorená e-regexami
\item LEregex -- trieda jazykov tvorená le-regexami
\end{list}

\section{Lookahead, lookbehind}
\label{chap:lookahead}

\begin{df}[Greedy iterácia]
$$ L_{1} \circledast L_{2} = \lbrace uv ~|~ u \in L_1^* \land v \in L_2 \land u~je~najdlhšie~také \rbrace$$
\end{df}

\begin{df}[Minimalistická iterácia]
$$ L_{1} *? L_{2} = \lbrace uv ~|~ u \in L_1^* \land v \in L_2 \land u~je~najkratšie~také \rbrace $$
\end{df}

\begin{veta}
$L_1 \circledast L_2 = L_1 *? L_2 = L_1^*L_2$
\end{veta}
\begin{proof}
$\subseteq:$
Nech $w \in L_1 \circledast L_2$. Potom z definície $w=uv$ vieme, že $u \in L_1^*$ a $v \in L_2$, teda $uv \in L_1^*L_2$. Analogicky ak $x=yz \in L_1 *? L_2$, potom $yz \in L_1^*L_2$.

$\supseteq:$
Majme $w \in L_1^*L_2$ a rozdeľme na podslová $u,v$ tak, že $u \in L_1^*, v \in L_2$ a $w=uv$. Takéto rozdelenie musí byť aspoň jedno. Ak je ich viac, vezmime to, kde je $u$ najdlhšie. Potom $uv \in L_1 \circledast L_2$. Ak zvolíme $u$ najkratšie, tak zasa $uv \in L_1 *? L_2$.
\end{proof}

\begin{dosledok}
Trieda $\R$ je uzavretá na operácie $\circledast$ a $*?$.
\end{dosledok}

\begin{df}[Pozitívny lookahead]
$$ L_{1}(?=L_{2})L_{3} = \lbrace uvw ~|~ u \in L_{1} \land v \in L_{2} \land vw \in L_{3} \rbrace $$ Operáciu $(?=\dots)$ nazývame pozitívny lookahead alebo len lookahead.
\end{df}

\begin{df}[Negatívny lookahead]
$$ L_{1}(?!L_{2})L_{3} = \lbrace uv ~|~ u \in L_{1} \land v \in L_{3} \land neexistuje~také~x,y,~že~v=xy~a~x \in L_2 \rbrace $$ Operáciu $(?!\dots)$ nazývame negatívny lookahead.
\end{df}

\begin{df}[Pozitívny lookbehind]
$$ L_{1}(?<=L_{2})L_{3} = \lbrace uvw ~|~ uv \in L_{1} \land v \in L_{2} \land w \in L_{3} \rbrace $$ Operáciu $(?<=\dots)$ nazývame pozitívny lookbehind alebo len lookbehind.
\end{df}

\begin{df}[Negatívny lookbehind]
$$ L_{1}(?<!L_{2})L_{3} = \lbrace uv ~|~ u \in L_{1} \land v \in L_{3} \land neexituje~také~x,y,~že~u=xy~a~y \in L_2 \rbrace $$ Operáciu $(?<!\dots)$ nazývame negatívny lookbehind.
\end{df}

\begin{veta} \label{lookahead+R}
Nech $ L_{1}, L_{2}, L_{3} \in \R $. Potom $ L = L_{1}(?=L_{2})L_{3} \in \R $.
\end{veta}
\begin{proof}
Keďže $ L_{1},L_{2},L_{3} $ sú regulárne, existujú $ A_{i} = (K_{i},\Sigma_{i},\delta_{i},q_{0i},F_{i}) $ DKA také, že $ L(A_{i})=L_{i}, i \in \lbrace 1,2,3\rbrace $. Zostrojím NKA $ A = (K,\Sigma,\delta,q_{0},F) $ pre $L$, kde
$ K = K_{1} \cup K_{2} \times K_{3} \cup K_{3} ~ ( $predp. $ K_{1} \cap K_{3}= \emptyset), ~
\Sigma=\Sigma_{1}\cup\Sigma_{2}\cup\Sigma_{3}, ~ q_{0}=q_{01}, ~ F = F_{3} \cup F_{2} \times F_{3}, ~ \delta $~funkciu definujeme nasledovne:
\begin{eqnarray*}
\forall q \in K_{1}, \forall a \in \Sigma &:& \delta(q,a) \ni \delta_{1}(q,a) \\
\forall q \in F_{1} &:& \delta(q,\varepsilon ) \ni \left[ q_{02},q_{03} \right] \\
\forall p \in K_{2}, \forall q \in K_{3}, \forall a \in \Sigma_{2} \cap \Sigma_{3} &:& \delta( \left[ p,q \right] ,a) \ni \left[ \delta(p,a), \delta (q,a) \right] \\
\forall p \in F_2, \forall q \in K_3 &:& \delta(\left[p,q\right],a) \ni \delta(q,a) 
\end{eqnarray*}

$ L(A) = L. $

$ \supseteq: $ Máme $ w \in L $ a chceme preň nájsť výpočet na $A$. Z definície $L$ vyplýva $w=xyz$, kde $x \in L_1, y \in L_2$ a $yz \in L_3$, teda existujú akceptačné výpočty pre $x,y,yz$ na DKA $A_1,A_2,A_3$. Z toho vyskladáme výpočet pre $w$ na $A$ nasledovne. Výpočet pre $x$ bude rovnaký ako na $A_1$. Z akceptačné stavu $A_1$ vieme na $\varepsilon$ prejsť do stavu $\left[q_{02},q_{03}\right]$, kde začne výpočet pre $y$. Ten vyskladáme z $A_2$ a $A_3$ tak, že si ich výpočty napíšeme pod seba a stavy nad sebou budú tvoriť karteziánsky súčin stavov v $A$ (keďže $A_2$ aj $A_3$ sú deterministické, tieto výpočty na $y$ budú rovnako dlhé). $y \in L_2$, teda $A_2$ skončí v akceptačnom stave. Podľa $\delta$ funkcie v $A$ vieme pokračovať len vo výpočte na $A_3$, teda doplníme zvyšnú postupnosť stavov pre výpočet $z$. Keďže $yz \in L_3$ a $F_3\subseteq F$ (resp. $F_2\times F_3\subseteq F$ pre $z=\varepsilon$), automat A akceptuje. 

$ \subseteq: $ Nech $w \in L(A)$, potom existuje akceptačný výpočet na $A$. Z toho vieme $w$ rozdeliť na $x,y$ a $z$ tak, že $x$ je slovo spracovávené od začiatku po prvý príchod do stavu $\left[q_{02},q_{03}\right]$, $y$ odtiaľto po posledný stav reprezentovaný karteziánskym súčinom stavov a zvyšok bude $z$. Nevynechali sme žiadne znaky a nezmenili poradie, teda $w=xyz$. Do $\left[q_{02},q_{03}\right]$ sa $A$ môže prvýkrát dostať len vtedy, ak bol v akceptačnom stave $A_1$. Prechod do $\left[q_{02},q_{03}\right]$ je na $\varepsilon$, takže $x \in L_1$. Práve tento stav je počiatočný pre $A_2$ aj $A_3$. Ak $z=\varepsilon$, tak akceptačný stav $A$ je z $F_2\times F_3$ a $y \in L_2, y \in L_3$ a aj $yz \in L_3$. Z toho podľa definície vyplýva, že $xyz=w \in L$. Ak $z\neq \varepsilon$, potom je akceptačný stav $A$ z $F_3$. Podľa $\delta$ funkcie sa z karteziánskeho súčinu stavov do normálneho stavu dá prejsť len tak, že $A_2$ akceptuje, teda $y \in L_2$. $A_3$ akceptuje na konci, čo znamená $yz \in L_3$. Znova podľa definície operácie lookahead $xyz=w \in L$.
\end{proof}

\begin{veta}
Nech $ L_{1}, L_{2}, L_{3} \in \R $. Potom $ L = L_{1}(?<=L_{2})L_{3} \in \R $.
\end{veta}
\begin{proof}
Podobne ako pri lookahead. (Karteziánsky súčin stavov $L_1$ a $L_2$, ale $A_2$ sa pripája v každom stave $A_1$ - celkový NKA si potom nedeterministicky zvolí jeden moment tohto napojenia.)
\end{proof}

\begin{veta}
$ \L_{CF} $ nie je uzavretá na operácie lookahead a lookbehind.
\end{veta}
\begin{proof}
Nech $ L_{1}, L_{2}, L_{3}, L_4 \in \L_{CF} $. $ L_1 = \lbrace a^nb^n ~|~ n\geq 1 \rbrace , L_2 = \lbrace a*b^nc^n ~|~ n\geq 1\rbrace , L_3 = \lbrace a^nb^nc* ~|~ n \geq 1\rbrace, L_4 = \lbrace ab^nc^n ~|~ n \geq 1 \rbrace$. Potom $ d(?=L_1)L_2 = \lbrace da^nb^nc^n ~|~ n\geq 1 \rbrace $ a $ L_3(?<=L_4)d = \lbrace a^nb^nc^nd ~|~ n\geq 1 \rbrace$, čo nie sú bezkontextové jazyky.
\end{proof}

\begin{veta} \label{CS-lookahead}
$ \L_{CS} $ je uzavretá na operáciu lookahead a lookbehind.
\end{veta} 
\begin{proof}
Uzavretosť na lookahead:

Pre $ L_{1}, L_{2}, L_{3} \in \L_{CS} $ a slovo z $ L = L_{1}(?=L_{2})L_{3} $ zostrojíme LBA $A$ z LBA $A_1, A_2, A_3$ pre dané kontextové jazyky. Najprv sa pozrime na štruktúru vstupu -- prvé je slovo z $L_1$ a za ním nasleduje slovo z $L_3$, pričom jeho prefix patrí do $L_2$. Preto, aby $A$ mohol simulovať dané lineárne ohraničené automaty, je potrebné označiť hranice jednotlivých slov.

 Na začiatku výpočtu $A$ prejde pásku a nedeterministicky označí 2 miesta -- koniec slov pre $A_1$ a $A_2$. Následne sa vráti na začiatok a simuluje $A_1$. Ak akceptuje, $A$ pokračuje a presunie sa za označený koniec vstupu pre $A_1$. Inak sa zasekne. V tomto bode sa začína vstup pre $A_2$ aj $A_3$, teda slovo až do konca prepíše na 2 stopy. Najprv na hornej simuluje $A_2$. Pokiaľ $A_2$ neskončí v akceptačnom stave, $A$ sa zasekne. Inak sa vráti na označené miesto a simuluje $A_3$ na spodnej stope až do konca vstupu. Akceptačný stav $A_3$ znamená akceptáciu celého vstupného slova.

Uzavretosť na lookbehind sa dokáže analogicky.
\end{proof}

Teraz ukážem, ako lookahead a lookbehind nezosilnia model regexov.

\begin{lema}\label{lookahead s *}
Nech $L_1,L_2,L_3,L_4 \in \R$, $\alpha = \left( L_1 \left( ?=L_2\right) L_3 \right) * L_4$. Potom $L(\alpha) \in \R$.
\end{lema} 
\begin{proof}
Keďže $L_1,L_2,L_3,L_4 \in \R$, tak pre ne existujú DKA $A_1,A_2,A_3,A_4$, kde $A_i = \left( K_i, \Sigma_i, \delta_i, q_{0i}, F_i \right)$ pre $\forall i$. Z nich zostrojíme NKA $A$ pre $L$. Výpočet bez lookaheadov by vyzeral tak, že by sme simulovali $A_1$, potom po jeho akceptácii $A_3$ a odtiaľ by sa išlo v rámci iterácie naspäť na $A_1$. Zároveň z $A_1$ by sa dalo na $\varepsilon$ prejsť na $A_4$, čo by znamenalo koniec iterácie (ošetruje aj nulovú iteráciu). Pozrime sa na to, ako a kam vsunúť lookahead. Problém je, že pri každej ďalšej iterácii pribúda nový, teda ďalší $A_2$. Vieme ich však simulovať všetky naraz, keď vezmeme do úvahy, že vždy pracujeme nad konečnou abecedou a $K_2$ je konečná. Z toho vyplýva, že aj $\P(K_2)$ je konečná.

Konštrukcia: $A = (K,\Sigma ,\delta ,q_0,F) : K = (K_1\cup K_3\cup K_4)\times \P(K_2)$, kde $K_1 \cap K_3 \cap K_4 = \emptyset$ (množiny v stavoch možno reprezentovať napr. 0-1 reťazcom dĺžky $\left\vert{K_2}\right\vert$, kde 1 na $i$--tom mieste symbolizuje, že nejaká inštancia $A_2$ je v $i$--tom stave), $\Sigma = \Sigma_1 \cup \Sigma_2 \cup \Sigma_3 \cup \Sigma_4, ~q_0 = (q_{01},\emptyset ), ~ F = F_4\times \emptyset,~\delta$--funkcia:
 
\begin{itemize}
  \item $\forall q \in K_i~i=1,3,4,\forall U \in \P(K_2),\forall a \in \Sigma : \delta ((q_i,U),a) \ni (\delta _i (q_i,a),V),$
  
  kde $\forall q \in U~\delta_2(q,a) \in V'$ a  $V=V'\setminus F_2$
  \item $\forall q_A \in F_1, \forall U \in \P(K_2) : \delta ((q_A,U),\varepsilon ) \ni (q_{03},U)$
  \item $\forall q_A \in F_3, \forall U \in \P(K_2) : \delta ((q_A,U),\varepsilon ) \ni (q_{01},U)$
  \item $\forall U \in \P(K_2) : \delta ((q_{01},U),\varepsilon ) \ni (q_{04},U)$
\end{itemize}

Automat $A$ akceptuje až keď akceptuje $A_4$. Je zrejmé, že ak v simulácii $A_i$ príde písmenko, ktoré do $\Sigma_i$ nepatrí, automat sa zasekne.

$L(A) = L(\alpha).$

$\subseteq:$ Nech $w \in L(A)$, potom preň existuje akceptačný výpočet na $A$. Podľa stavov vieme určiť počet iterácií, časti z $L_1,L_3,L_4$ a takisto vznikajúce a akceptujúce výpočty na $A_2$ -- každý takýto výpočet totiž začína s výpočtom na $A_3$ a keďže $A_2$ je deterministický, existuje práve jeden výpočet, ktorý musí byť akceptačný. Teda vieme povedať, že $w = x_1y_1x_2y_2 \dots x_ny_nz$, kde $n$ je počet iterácií, $\forall i = 1, 2, \dots, n : ~ x_i \in L_1, y_i \in L_3 $ a $z \in L_4$. Zároveň vieme, že v mieste, kde začína $y_i$ takisto začína podreťazec slova $w$, ktorý patrí do $L_2$. Z toho vidíme ako vyzerá zhoda regexu $\alpha$.

$\supseteq:$ Majme $v \in L(\alpha)$, teda vieme nájsť zhody podslov $v$ pre všetky $L_i$ (rovnaká dekompozícia slova ako v predošlej inklúzii). Keďže poradie jazykov je rovnaké ako $\varepsilon$--ové napojenie stavov v $A$ (akceptačný--počiatočný, akceptačný--akceptačný pri $L_4$), vieme správne poprepájať akceptačné výpočty jednotlivých $A_i$ do celkového výpočtu automatu $A$.
\end{proof}

\begin{veta}
Regexy sú uzavreté na lookahead.
\end{veta}
\begin{proof}
Regexy pokrývajú triedu regulárnych jazykov a tá je na lookahead uzavretá \ref{lookahead+R}. Keďže pracujeme s množinou operácií, treba overiť, či nejaká ich kombinácia nie je náhodou silnejšia. Ak regex umiestnime do lookaheadu, či pred alebo za neho, vždy to bude regulárny jazyk a celý regex bude tiež definovať regulárny jazyk. Teda nás zaujíma vloženie lookaheadu dovnútra vykonávanej operácie. V tomto prípade prichádza do úvahy $*,+$ a $?$.

$?$ veľa nespraví -- lookahead tam buď bude 1x alebo nebude vôbec. $+$ je prípad $*$ jedným lookaheadom istým. No a podľa lemy \ref{lookahead s *} vieme, že ani táto kombinácia nestačí na zložitejší jazyk.
\end{proof}

Nejaké vlastnosti lookaheadu.
Tu ukážem, že dávať do lookaheadu prefixový jazyk nemá zmysel. Vytvorme čisto jazyk všetkých rôznych prefixov, aké obsahuje. Do lookaheadu stačí vložiť regex pre tento jazyk a celkový akceptovaný jazyk zostane rovnaký(zhodovať sa s...? \todo). Samozrejme, to isté platí aj pre lookbehind a sufixové jazyky.

\begin{veta}
Nech $L$ je ľubovoľný jazyk a $L_p = L \cup \lbrace uv ~|~ u \in L \rbrace$. Nech $\alpha$ je ľubovoľný regulárny výraz taký, že obsahuje $(?=L_p)$. Potom ak prepíšeme tento lookahead na $(?=L)$ (nazvime to $\alpha '$), bude platiť $L(\alpha ') = L(\alpha )$.
\end{veta}
\begin{proof}
$\subseteq :$ triviálne.

$\supseteq :$ Majme $w \in L(\alpha)$ a nech $x$ je také podslovo w, ktoré sa zhodovalo práve s daným lookaheadom. Potom $x \in L^p$, teda $x=uv$, kde $u \in L$. Ak $v=\varepsilon$, $x \in L$ a máme čo sme chceli. Takže $v\neq \varepsilon$. Ale celá zhoda lookaheadu sa môže zúžiť len na $u$, keďže $u \in L_p$, a bude to platná zhoda s $w$. Čo znamená, že $w \in L(\alpha ')$.
\end{proof}

\begin{veta}
Nech $\alpha$ je regulárny výraz, ktorý obsahuje nejaký taký lookahead $(?=L)$ (lookbehind $(?<=L)$), že $\varepsilon \in L$. Nech je $\alpha '$ regulárny výraz bez tohto lookaheadu (lookbehindu). Potom $L(\alpha ') = L(\alpha)$.
\end{veta}
\begin{proof}
Uvedomme si, že lookaround nie je fixovaný na dĺžku vstupu - musí sa zhodovať s nejakým podslovom začínajúcim (končiacim) na konkrétnom mieste. Tým pádom akonáhle si môže regulárny výraz vnútri tPotomejto operácie vybrať $\varepsilon$, bude hlásiť zhodu vždy.
\end{proof}

\section{Spätné referencie}\label{chap:backref}

Rozšírme regexy o spätné referencie, túto množinu operácií nazvem e-regex. V tejto časti ma bude zaujímať, čo sa stane, ak k tomuto modelu pridáme ešte lookahead a lookbehind. Najprv však uvediem základné informácie o triede e-regexov.

Spätná referencia (angl. \textit{backreference}) je v e-regexoch označená ako $ \backslash m $. Očíslujme okrúhle zátvorky zľava doprava podľa poradia ľavej zátvorky a zoberme podslovo, ktoré akceptoval výraz vnútri $m$-tých zátvoriek. $ \backslash m $ bude predstavovať presne tento reťazec (pri inom slove teda môže byť iným reťazcom). Budem predpokladať, že spätná referencia s číslom $m$ sa bude nachádzať až za pravou zátvorkou s číslom $m$.

Triedu jazykov e-regexov budem nazývať Eregex, presná definícia sa nachádza v článku \cite{ExtendedRegexPower}. (Autori ju pôvodne nazvali extended regex resp. EREG, avšak pre lepšiu prehľadnosť v tejto práci som názov upravila.)

Uvediem najprv niektoré fakty o tejto triede.
Trieda Eregex je podmnožinou $\L_{CS}$, ale existujú jazyky z $\L_{CF}$ aj $\L_{CS}$, ktoré do nej nepatria. Je uzavretá na homomorfizmus a nie je uzavretá na komplement, inverzný homomorfizmus, konečnú substitúciu, shuffle s regulárnym jazykom \cite{ExtendedRegexPower} a prienik \cite{ExtendedRegexIntersec}.

\begin{df}
Množinu e-regex obohatenú o pozitívny lookahead a pozitívny lookbehind budem nazývať le-regex.
\end{df}

\begin{df}
Triede jazykov tvorenej le-regexami budem hovoriť LEregex.
\end{df}

Tu si definujme model na reprezentáciu le-regexov.

\todo just idea; uvidim este co s touto definiciou (je to naviazanie na def. z jedneho clanku)
\begin{df}
Nech $\alpha$ je le-regex. Nech $\alpha '$ je rovnaký ako $\alpha$, akurát bez operácií lookahead a lookbehind. Potom $\alpha ' \in Eregex$ a teda je reprezentovaný stromom $T_{\alpha '}$ podľa definície triedy Eregex. Zostrojme konečný (orientovaný, usporiadaný) výpočtový strom $S_\alpha$ z $T_{\alpha '}$ tak, že pridáme lookahead/lookbehind do vrcholu, kam zapadne pri postupnom rozkladaní regexu od koreňa a urobíme s ním nasledovné:
\begin{itemize}
  \item  $\alpha$ obsahuje lookahead, teda $S_\alpha$ má niekde vrchol $(u, (?=\beta_1 )\beta_2)$. Potom tento vrchol bude mať dvoch synov - vrchol $(u,\beta_2)$, ktorý pokračuje ako v $T_{\alpha '}$, a virtuálny vrchol $(u,\beta_1 (.*))$, ktorý sa ďalej rozloží podľa definície.
  \item  $\alpha$ obsahuje lookbehind, teda $S_\alpha$ má niekde vrchol $(u, \beta_1(?<=\beta_2))$. Potom tento vrchol bude mať dvoch synov - vrchol $(u,\beta_1)$, ktorý pokračuje ako v $T_{\alpha '}$, a virtuálny vrchol $(u,(.*)\beta_2)$, ktorý sa ďalej rozloží podľa definície.
  \item všetky ostatné vrcholy sú rovnaké ako v $T_{\alpha '}$
\end{itemize}
Jazyk popísaný le-regexom $\alpha$ je definovaný nasledovne: 
$$L(\alpha ) = \lbrace w \in \Sigma ^* ~|~ (w, \alpha)~je~koreňom~nejakého~výpočtového~stromu~S_\alpha \rbrace$$
\end{df}

\begin{veta}
$ Eregex \subsetneq LEregex $
\end{veta}
\begin{proof}
$ \subseteq $ vyplýva z definície.

Jazyk $L = \lbrace a^iba^{i+1}ba^k ~|~ k=i(i+1)k' ~ pre ~ nejaké ~ k'>0, i>0 \rbrace$ nepatrí do triedy Eregex \cite[Lemma 2]{ExtendedRegexIntersec}, ale patrí do LEregex:
$$ \alpha = (a*)b(\backslash 1a)b(?=(\backslash 1)* \mathdollar )(\backslash 2)* \mathdollar $$
\end{proof}

\begin{veta}
$ LEregex \subseteq \L_{CS} $
\end{veta}
\begin{proof}
Vyplýva z vety \ref{CS-lookahead} a toho, že $ Eregex \in \L_{CS} $.
\end{proof}

\begin{veta}
LEregex je uzavretá na prienik.
\end{veta}
\begin{proof}
Nech $L_1,L_2 \in LEregex$, potom $L_1 \cap L_2 = \left( ?= L_1 \mathdollar \right) L_2 \mathdollar $.
\end{proof}

\begin{veta}
LEregex je uzavretá na homomorfizmus.
\end{veta}
\begin{proof}
Nech $\alpha$ je le-regex a $h$ ľubovoľný homomorfizmus. Zoberme $w \in L(\alpha)$, existuje preň výpočtový strom $S_\alpha$ s koreňom $(w,\alpha)$. Aplikujme teraz na celý strom homomorfizmus $h$ - t.j. vrchol $(u,\beta)$ bude $(h(u),h(\beta))$, pričom homomorfizmus na le-regexe vyzerá tak, že mení iba abecedu jazyka a znaky operácií zostávajú rovnaké. Ak $h(a) = a_1a_2\dots a_n$ pre nejaké $a$ a $n \geq 2$, potom v niektorých listoch zostal reťazec písmeniek a treba ho rozvetviť. Ak $h$ je vymazávací, potom treba zmazať vrcholy $(\varepsilon,\varepsilon)$. Jediné povolené $\varepsilon$--ové vrcholy majú totiž tvar $(\varepsilon,\beta)$, kde $\beta = \beta_1 *$ alebo $\beta = \beta_1 ?$. Teraz máme korektný výpočtový strom pre $h(w)$, čo platí pre ľubovoľné $w$, z čoho vyplýva $h(L(\alpha)) \subseteq L(h(\alpha)) \subseteq LEregex$. Druhá inklúzia platí, pretože $h(\alpha)$ je tiež korektný le-regex.
\end{proof}


Triedu LEregex obohatenú o negatívny lookahead a negatívny lookbehind budeme nazývať L!Eregex.

\begin{veta}
L!Eregex je uzavretá na komplement.
\end{veta}
\begin{proof}
Nech $L_1 \in LEregex$, potom $L_1^c  = \left( ?! L_1 \mathdollar \right) .* \mathdollar $.
\end{proof}

\begin{veta}
\end{veta}
\begin{proof}
\end{proof}


