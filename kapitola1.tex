\chapter{Definície a známe výsledky}
\label{chap:kapitola1}

Keďže implementované regulárne výrazy sa už natoľko líšia od počiatočného teoretického modelu, zaužíval sa pre ne názov \textbf{regexy}. Budeme ho používať aj my a prípadnými predponami budeme rozlišovať, ktorú množinu operácií práve myslíme.

\section{Základná definícia regulárnych výrazov}
\sectionmark{Zákl. definícia}
\label{def}

Pojem \textbf{regex} bude slúžiť na pomenovanie regulárnych výrazov, ktoré pokrývajú triedu regulárnych jazykov. Z tohto dôvodu nebudeme vytvárať zvlášť pomenovanie pre túto triedu, bolo by to zbytočné. Pre ozrejmenie uvedieme základnú definíciu regexu z článku \cite{ExtendedRegexPower}. Niektoré konštrukcie sú oproti teoretickému modelu nové, ale dôkaz toho, že pokrýva stále rovnakú triedu jazykov, je triviálny.

\underline{Základná forma regexov}
\begin{list}{}{}
\item[(1)] Pre každé $a \in \Sigma$, $a$ je regex a $L(a)=\lbrace a \rbrace$. Poznamenajme, že pre každé $x \in \lbrace (,), \{, \},[,],\mathdollar,|, \backslash, .,?,*,+ \rbrace, \backslash x \in \Sigma $ a je regexom a $L(\backslash x) = \lbrace x \rbrace$. Naviac aj $\backslash n$ a $\backslash t$ patria do $\Sigma$ a oba sú regexami. $L(\backslash n)$ a $L(\backslash t)$ popisujú jazyky skladajúce sa z nového riadku a tabulátora.
\item[(2)] Pre regexy $e_1$ a $e_2$ 
\begin{list}{}{}
\item $(e_1)(e_2)$ (zreťazenie), 
\item $(e_1)|(e_2)$ (alternácia), a 
\item $(e_1)*$ (Kleeneho uzáver) 
\end{list}
sú regexy, kde $L((e_1)(e_2)) = L(e_1)L(e_2), L((e_1)|(e_2))=L(e_1) \cup L(e_2)$ a $L((e_1)*) = (L(e_1))^*$. Okrúhle zátvorky môžu byť vynechané. Ak sú vynechané, alternácia, zreťazenie a Kleeneho uzáver majú vyššiu prioritu.
\item[(3)] Regex je tvorený konečným počtom prvkov z (1) a (2).
\end{list}

\underline{Skrátnená forma}
\begin{list}{}{}
\item[(1)] Pre každý regex $e$: $(e)+$ je regex a $(e)+ \equiv e(e)*$.
\item[(2)] Znak ' . ' znamená ľubovolný znak okrem $\backslash n$.
\end{list}

\underline{Triedy znakov}
\begin{list}{}{}
\item[(1)] Pre $a_{i_1},a_{i_2},\dots ,a_{i_t} \in \Sigma,~t \geq 1,~\left[ a_{i_1}a_{i_2}\dots a_{i_t} \right] \equiv a_{i_1}|a_{i_2}|\dots |a_{i_t} $.
\item[(2)] Pre $a_i,a_j \in \Sigma$ také, že $a_i\leq a_j,~ [a_i-a_j]$ je regex a $[a_i-a_j]\equiv a_i|a_{i+1}|\dots |a_j$.
\item[(3)] Pre $a_{i_1},a_{i_2},\dots ,a_{i_t} \in \Sigma,~t \geq 1,~\left[ \textasciicircum a_{i_1}a_{i_2}\dots a_{i_t} \right] \equiv b_{i_1}|b_{i_2}|\dots |b_{i_s} $, kde $\lbrace b_{i_1}|b_{i_2}|\dots |b_{i_s}\rbrace = \Sigma - \lbrace a_{i_1},a_{i_2},\dots ,a_{i_t} \rbrace$.
\item[(4)] Pre $a_i,a_j \in \Sigma$ také, že $a_i\leq a_j,~ [a_i-a_j]$ je regex a $[\textasciicircum a_i-a_j]\equiv b_{i_1}|b_{i_2}|\dots |b_{i_s}$, kde $\lbrace b_{i_1}|b_{i_2}|\dots |b_{i_s}\rbrace = \Sigma - \lbrace a_i|a_{i+1}|\dots |a_j \rbrace$.
\item[(5)] Zmes (1) a (2) alebo (3) a (4).
\end{list}

\underline{Ukotvenie}
\begin{list}{}{}
\item[(1)] Znak pre začiatok riadku $ \textasciicircum $.
\item[(2)] Znak pre koniec riadku $ \mathdollar $.
\end{list}

Vo formálnom texte bude prirodzené pomenovávať ľubovoľný model regexov pomocou písmen gréckej abecedy.

Rada by som spomenula aj iné konštrukcie, ktoré v definícii chýbajú. V konečnom dôsledku síce modelu silu nepridajú, ale budem s nimi rátať v ďalšom výskume, nakoľko sa bavíme o moderných regulárnych výrazoch.

\begin{itemize}
\item $*?,+?,??$ definované ako $*,+,?$, ale snažia sa matchovať čo najmenej znakov ($*,+,?$ sú greedy)
\item $\lbrace m \rbrace$ -- matchuje práve $m$ kópií predošlého regexu; $m \in \N$ je konštanta
\item $ \lbrace m,n \rbrace$ -- matchuje aspoň $m$ a najviac $n$ kópií predošlého regexu, matchuje čo najviac; $m, n \in \N$ sú konštanty
\item $ \lbrace m,n \rbrace ?$ -- ako $ \lbrace m,n \rbrace$, ale matchuje čo najmenej
\item $(?\#\dots )$ komentár, pri matchovaní sa obsah ignoruje
\end{itemize}

Pre ľahší dôkaz uvediem formálnu definíciu pre prvú operáciu a operáciu, ktorej algoritmus sa používa na simulovanie Kleeneho $*$.

\begin{df}[Greedy iterácia]
$$ L_{1} \circledast L_{2} = \lbrace uv ~|~ u \in L_1^* \land v \in L_2 \land u~je~najdlhšie~také \rbrace$$
\end{df}

\begin{df}[Minimalistická iterácia]
$$ L_{1} *? L_{2} = \lbrace uv ~|~ u \in L_1^* \land v \in L_2 \land u~je~najkratšie~také \rbrace $$
\end{df}

V sekcii \ref{iteracia} dokážem, že tieto iterácie pokrývajú rovnakú triedu jazykov ako Kleeneho $*$. Ostatné operácie sa ľahko prepíšu na už definované regexy, preto triedu jazykov nad regexami nerozšíria o žiaden nový jazyk. Poďme sa teda venovať tým zložitejsím a zaujímavejším operáciám.

\section{Spätné referencie}\label{chap:backref1}

Spätná referencia (angl. \textit{backreference}) je označovaná ako $ \backslash m $, kde $m \in \N$ je kon\-štan\-ta. Predstavuje reťazec, ktorý matchoval regex vnútri $m$--tých okrúhlych zátvoriek. Okrúhle zátvorky číslujeme zľava doprava podľa poradia ľavej zátvorky. Samozrejme, $\backslash m$ môže ukazovať na zátvorky, ktoré obsahujú regex s inými spätnými referenciami. Vždy však budeme predpokladať, že spätná referencia s číslom $m$ sa bude nachádzať až za pravou zátvorkou s číslom $m$.

Regexy rozšírené o spätné referencie budeme nazývať \textbf{e-regex}. Triedu jazykov nad e-regexami budem nazývať \textbf{Eregex}\footnote{Autori ju pôvodne nazvali extended regex resp. EREG, avšak pre lepšiu prehľadnosť v tejto práci sme názov upravili.}, presná definícia sa nachádza v článku \cite{ExtendedRegexPower}.  Narába s regexami uvedenými iba v úvodnej definícii, ale myslíme, že je zrejmé, že nové operácie nepridajú modelu silu, preto môžeme pracovať s touto rozšírenou množinou.

Dospelo sa k nasledujúcim výsledkom:
\begin{itemize}
\item V rámci Chomského hierarchie je trieda Eregex vlastnou podmnožinou $\L_{CS}$. Existujú jazyky z $\L_{CF}$ aj $\L_{CS}$, ktoré do nej nepatria.
\item  Čo sa týka uzáverových vlastností, trieda je uzavretá na homomorfizmus a nie je uzavretá na komplement, inverzný homomorfizmus, konečnú substitúciu, shuffle s regulárnym jazykom. Neuzavretosť na prienik sa podarilo dokázať až v článku \cite{ExtendedRegexIntersec}.
\item Nekonečné jazyky z Eregex sa dajú pumpovať, dokázali sa už 2 verzie pumpovacej lemy (\cite[Lemma 1]{ExtendedRegexPower}, \cite[Lemma 3]{ExtendedRegexIntersec}).
\end{itemize}

\section{Lookaround}
\label{dflookaround}

Lookaround je spoločný názov pre dve operácie -- lookahead a lookbehind. Tieto operácie nás v práci budú zaujímať. Je to niečo nové a málo skúmané. Teraz si uvedieme ich popis a definície. Ako fungujú? 

Zoberme si lookahead. Už názov naznačuje, že to bude nazeranie dopredu. Myšlienka spočíva v tom, že si chceme povedať, čo má za nejakým hľadaným slovom nasledovať. Teda nájdeme slovo a potom nazrieme dopredu a overíme, či tam je to, čo chceme. Táto operácia 'nevyjedá' písmenká, čiže keď lookahead skončí a uspeje, pokračuje sa v ďalšom matchovaní akokeby tam nebol -- presne od toho miesta, kde on začal pracovať. Presnejšie: slovo sa matchuje podľa regexu. Keď narazíme na lookahead, zapamätáme si toto miesto. Matchujeme podľa lookaheadu. Ak uspeje, potom sa v slove vrátime na zapamätané miesto a pokračujeme v matchovaní regexom za lookaheadom.

Lookbehind pracuje analogicky, ale pozerá sa dozadu -- teda chceme vedieť, čo hľadanému slovu predchádza. V praxi by sa toto riešilo backtrackingom, lebo nevieme vopred ako ďaleko dozadu sa budeme potrebovať pozrieť. A keďže autori programovacích jazykov nechceli príliš spomaľovať výpočty a asi nepovažovali lookbehind za taký dôležitý, určili si, že môže obsahovať iba také regexy, z ktorých je jasne určiteľné aký dlhý reťazec bude potrebovať na výpočet (takže sa backtrackingu vyhli). My sme však v teoretickom prostredí a primárne nás bude zaujímať veľkosť triedy, ktorú budeme vedieť popísať aj pomocou týchto operácií, preto sme sa rozhodli na obmedzenia zabudnúť. Je však jasné, že reálny model bude akousi podmnožinou toho nášho.

\begin{df}[Pozitívny lookahead]
$$ L_{1}(?=L_{2})L_{3} = \lbrace uvw ~|~ u \in L_{1} \land v \in L_{2} \land vw \in L_{3} \rbrace $$ Operáciu $(?=\dots)$ nazývame pozitívny lookahead alebo len lookahead.
\end{df}

\begin{df}[Pozitívny lookbehind]
$$ L_{1}(?<=L_{2})L_{3} = \lbrace uvw ~|~ uv \in L_{1} \land v \in L_{2} \land w \in L_{3} \rbrace $$ Operáciu $(?<=\dots)$ nazývame pozitívny lookbehind alebo len lookbehind.
\end{df}

Negatívna verzia funguje rovnako, ale otáča akceptačnú požiadavku -- namiesto toho, aby sme písali, čo nasleduje, definujeme práve to, čo nechceme aby nasledovalo. Teda negatívny lookaround 'zbehne', ak nie je schopný matchovať vstup.

\begin{df}[Negatívny lookahead]
$$ L_{1}(?!L_{2})L_{3} = \lbrace uv ~|~ u \in L_{1} \land v \in L_{3} \land neexistuje~také~x,y,~že~v=xy~a~x \in L_2 \rbrace $$ Operáciu $(?!\dots)$ nazývame negatívny lookahead.
\end{df}

\begin{df}[Negatívny lookbehind]
$$ L_{1}(?<!L_{2})L_{3} = \lbrace uv ~|~ u \in L_{1} \land v \in L_{3} \land neexituje~také~x,y,~že~u=xy~a~y \in L_2 \rbrace $$ Operáciu $(?<!\dots)$ nazývame negatívny lookbehind.
\end{df}

Nachádza sa tu ešte jeden rozdiel od reálneho modelu, na ktorý by sme chceli upozorniť. Regulárne výrazy sa začali využívať na vyhľadávanie v texte. V tomto kontexte má lookaround iný význam ako v teoretickom prostredí. Využíva sa to, že nevyjedá písmenká a preto sa dá použiť v takých prípadoch, kedy si chceme označiť slovo $w$, ale vieme, že hľadáme slovo $v$, pričom $w$ je podslovo $v$. Teda v takom prípade môže lookahead ďaleko presahovať slovo, na ktoré sme vyhlásili zhodu. Z toho vyplýva, že my by sme na vstup nechceli dostať $w$, ale $v$. V teoretickom prostredí nás však zaujíma slovo, ktoré do jazyka patrí a na jeho okolie sa nepozeráme, v podstate ho ani nemáme k dispozícii. Preto sa zdá, že budeme na vstupe očakávať $w$ a lookahead či lookbehind nebudú môcť presahovať za hranice slova. Táto úprava však neuškodí, nakoľko vieme z daného $w$ spraviť $v$ jednoduchým pridaním $(.*)$ na správne miesta.
